'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _symbol = require('babel-runtime/core-js/symbol');

var _symbol2 = _interopRequireDefault(_symbol);

exports.default = run;

var _path = require('path');

var _timeoutAsPromise = require('timeout-as-promise');

var _timeoutAsPromise2 = _interopRequireDefault(_timeoutAsPromise);

var _crossSpawn = require('cross-spawn');

var _crossSpawn2 = _interopRequireDefault(_crossSpawn);

var _spawnArgs = require('spawn-args');

var _spawnArgs2 = _interopRequireDefault(_spawnArgs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const timedOutSymbol = (0, _symbol2.default)('TIMED_OUT');

function run() {
  let command = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // Expand and fill in the defaults for the options
  var _options$quiet = options.quiet;
  const quiet = _options$quiet === undefined ? false : _options$quiet;
  var _options$ignoreErrors = options.ignoreErrors;
  const ignoreErrors = _options$ignoreErrors === undefined ? false : _options$ignoreErrors;
  var _options$cwd = options.cwd;
  const cwd = _options$cwd === undefined ? process.cwd() : _options$cwd;
  var _options$timeout = options.timeout;
  const timeout = _options$timeout === undefined ? undefined : _options$timeout;
  var _options$env = options.env;
  const env = _options$env === undefined ? {} : _options$env;

  // Ensure that commands is an array

  const commands = Array.isArray(command) ? command : [command];

  // Returning an async function lets gulp know it's complete when the promise resolves
  return (0, _asyncToGenerator3.default)(function* () {
    // Loop over each command and run them one-at-a-time
    for (let cmd of commands) {
      // Wrap it in a try/catch to ignore errors if ignoreErrors is set
      try {
        // Run the command and add the promise to the promise array
        const promiseArray = [runCommand(cmd, quiet, ignoreErrors, (0, _path.resolve)(cwd), env)];
        // If timeout is set, then add that as a timebomb to the promise array
        if (typeof timeout !== 'undefined') promiseArray.push((0, _timeoutAsPromise2.default)(parseInt(timeout, 10), timedOutSymbol));

        // Finally, await on a race between the promises to deal with the first of them
        const promiseResult = yield _promise2.default.race(promiseArray);

        // If the promise resolves with timedOutSymbol first, then throw an error
        if (promiseResult === timedOutSymbol) {
          throw new Error('Process timed out...');
        }
      } catch (err) {
        // Unless ignoreErrors is true, re-throw the caught error
        if (!ignoreErrors) {
          throw err;
        }
      }
    }
  });
}

const runCommand = (command, quiet, ignoreErrors, cwd, env) => new _promise2.default(resolve => {
  // Parse out the args from the command
  const args = (0, _spawnArgs2.default)(command, { removequotes: 'always' });

  // Run the command
  const proc = (0, _crossSpawn2.default)(args.shift(), args, {
    stdio: ['ignore', // ignore stdin
    quiet ? 'ignore' : 'inherit', // ignore or inherit stdout depending on quiet flag
    quiet ? 'ignore' : 'inherit'],
    cwd: cwd, // Set the current working directory
    env: (0, _extends3.default)({}, process.env, { // Include the process's environment
      PATH: process.env.PATH + _path.delimiter + (0, _path.resolve)(cwd, 'node_modules', '.bin') }, env)
  });

  // On error, throw the err back up the chain
  proc.on('error', err => {
    if (!ignoreErrors) {
      throw err;
    } else {
      resolve();
    }
  });

  // On exit, check the exit code and if it's good, then resolve
  proc.on('exit', code => {
    if (parseInt(code, 10) === 0) {
      resolve();
    } else {
      if (!ignoreErrors) {
        throw new Error(`Non-zero exit code of "${code}"`);
      } else {
        resolve();
      }
    }
  });
});

