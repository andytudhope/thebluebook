'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _const = require('../const');

var _node = require('./node');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var parser = null;

var Parser = function () {
  function Parser() {
    _classCallCheck(this, Parser);
  }

  _createClass(Parser, [{
    key: '_parseRules',
    value: function _parseRules(src, ruleNames) {
      var defaultType = arguments.length <= 2 || arguments[2] === undefined ? 'text' : arguments[2];

      ruleNames = ruleNames || _const.INJECTION_POINTS;
      var rules = ruleNames.map(function (i) {
        return _const.REGEX[i];
      });

      var delta = 0;

      var _rules$reduce = rules.reduce(function (context, r, i) {
        var ruleName = ruleNames[i];

        var _ruleName$split = ruleName.split('_');

        var _ruleName$split2 = _slicedToArray(_ruleName$split, 2);

        var rule = _ruleName$split2[0];
        var pos = _ruleName$split2[1];

        var isEnd = pos === 'end';
        var m = r.exec(context.text);
        if (m) {
          delta++;
          var tag = m[1];
          var offset = m.index;
          var before = context.text.substr(0, offset);
          var remain = context.text.substr(offset + tag.length);
          context.text = remain;
          if (before !== '') {
            context.tokens.push({
              type: isEnd ? rule + '_text' : defaultType,
              content: before
            });
          }
          context.tokens.push({
            type: ruleName,
            content: tag
          });
        }
        return context;
      }, { text: src, tokens: [] });

      var tokens = _rules$reduce.tokens;
      var text = _rules$reduce.text;


      if (text !== '') {
        if (delta === 0) {
          tokens.push({
            type: defaultType,
            content: text
          });
        } else {
          tokens = tokens.concat(this._parseRules(text, ruleNames, defaultType));
        }
      }
      return tokens;
    }
  }, {
    key: '_tokenize',
    value: function _tokenize(src) {
      var tokens = this._parseRules(src);

      var INJECTION_REGION = ['injection_begin', 'injection_end'];

      var headIndex = tokens.findIndex(function (t) {
        return t.type === 'head_text';
      });
      this._expandToken(tokens, headIndex, INJECTION_REGION);

      var bodyIndex = tokens.findIndex(function (t) {
        return t.type === 'body_text';
      });
      this._expandToken(tokens, bodyIndex, INJECTION_REGION);

      return tokens;
    }
  }, {
    key: '_expandToken',
    value: function _expandToken(tokens, index, ruleNames) {
      if (index < 0) return;
      var token = tokens[index];
      tokens.splice.apply(tokens, [index, 1].concat(_toConsumableArray(this._parseRules(token.content, ruleNames, token.type))));
    }
  }, {
    key: '_reduceBlock',
    value: function _reduceBlock(tokens) {
      var root = new _node.Document();
      var stack = [root];

      function top() {
        return stack[stack.length - 1];
      }

      tokens.forEach(function (token) {
        var _token$type$split = token.type.split('_');

        var _token$type$split2 = _slicedToArray(_token$type$split, 2);

        var t = _token$type$split2[0];
        var p = _token$type$split2[1];

        switch (p) {
          case 'begin':
            stack.push(_node.Block.make(t, token));
            break;
          case 'end':
            var block = stack.pop();
            if (block.type !== t) throw new SyntaxError('No matching \'' + t + '_begin\'');
            block.end = token;
            top().append(block);
            break;
          default:
            top().append(token);
        }
      });

      if (stack.length > 1) throw new SyntaxError('No matching \'' + top().type + '_end\'');

      return root;
    }
  }, {
    key: 'parse',
    value: function parse(src) {
      var tokens = this._tokenize(src);

      var doc = this._reduceBlock(tokens);

      return doc;
    }
  }], [{
    key: 'get',
    value: function get() {
      if (parser === null) parser = new Parser();
      return parser;
    }
  }]);

  return Parser;
}();

exports.default = Parser;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,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OzswQkEyQmYsS0FBSztBQUNWLFVBQUksU0FBUyxLQUFLLFNBQUwsQ0FBZSxHQUFmLENBQVQsQ0FETTs7QUFHVixVQUFJLE1BQU0sS0FBSyxZQUFMLENBQWtCLE1BQWxCLENBQU4sQ0FITTs7QUFLVixhQUFPLEdBQVAsQ0FMVTs7OzswQkE1RkU7QUFDWixVQUFJLFdBQVcsSUFBWCxFQUFpQixTQUFTLElBQUksTUFBSixFQUFULENBQXJCO0FBQ0EsYUFBTyxNQUFQLENBRlk7Ozs7U0FESyIsImZpbGUiOiJwYXJzZXIvaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJTkpFQ1RJT05fUE9JTlRTLCBSRUdFWCB9IGZyb20gJy4uL2NvbnN0J1xyXG5pbXBvcnQgeyBCbG9jaywgRG9jdW1lbnQgfSBmcm9tICcuL25vZGUnXHJcblxyXG52YXIgcGFyc2VyID0gbnVsbFxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJzZXIge1xyXG4gIHN0YXRpYyBnZXQgKCkge1xyXG4gICAgaWYgKHBhcnNlciA9PT0gbnVsbCkgcGFyc2VyID0gbmV3IFBhcnNlcigpXHJcbiAgICByZXR1cm4gcGFyc2VyXHJcbiAgfVxyXG4gIF9wYXJzZVJ1bGVzIChzcmMsIHJ1bGVOYW1lcywgZGVmYXVsdFR5cGUgPSAndGV4dCcpIHtcclxuICAgIHJ1bGVOYW1lcyA9IHJ1bGVOYW1lcyB8fCBJTkpFQ1RJT05fUE9JTlRTXHJcbiAgICBsZXQgcnVsZXMgPSBydWxlTmFtZXMubWFwKChpKSA9PiBSRUdFWFtpXSlcclxuXHJcbiAgICBsZXQgZGVsdGEgPSAwXHJcbiAgICBsZXQgeyB0b2tlbnMsIHRleHQgfSA9IHJ1bGVzLnJlZHVjZSgoY29udGV4dCwgciwgaSkgPT4ge1xyXG4gICAgICBsZXQgcnVsZU5hbWUgPSBydWxlTmFtZXNbaV1cclxuICAgICAgbGV0IFtydWxlLCBwb3NdID0gcnVsZU5hbWUuc3BsaXQoJ18nKVxyXG4gICAgICBsZXQgaXNFbmQgPSBwb3MgPT09ICdlbmQnXHJcbiAgICAgIGxldCBtID0gci5leGVjKGNvbnRleHQudGV4dClcclxuICAgICAgaWYgKG0pIHtcclxuICAgICAgICBkZWx0YSsrXHJcbiAgICAgICAgbGV0IHRhZyA9IG1bMV1cclxuICAgICAgICBsZXQgb2Zmc2V0ID0gbS5pbmRleFxyXG4gICAgICAgIGxldCBiZWZvcmUgPSBjb250ZXh0LnRleHQuc3Vic3RyKDAsIG9mZnNldClcclxuICAgICAgICBsZXQgcmVtYWluID0gY29udGV4dC50ZXh0LnN1YnN0cihvZmZzZXQgKyB0YWcubGVuZ3RoKVxyXG4gICAgICAgIGNvbnRleHQudGV4dCA9IHJlbWFpblxyXG4gICAgICAgIGlmIChiZWZvcmUgIT09ICcnKSB7XHJcbiAgICAgICAgICBjb250ZXh0LnRva2Vucy5wdXNoKHtcclxuICAgICAgICAgICAgdHlwZTogaXNFbmQgPyBgJHtydWxlfV90ZXh0YCA6IGRlZmF1bHRUeXBlLFxyXG4gICAgICAgICAgICBjb250ZW50OiBiZWZvcmVcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQudG9rZW5zLnB1c2goe1xyXG4gICAgICAgICAgdHlwZTogcnVsZU5hbWUsXHJcbiAgICAgICAgICBjb250ZW50OiB0YWdcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjb250ZXh0XHJcbiAgICB9LCB7IHRleHQ6IHNyYywgdG9rZW5zOiBbXSB9KVxyXG5cclxuICAgIGlmICh0ZXh0ICE9PSAnJykge1xyXG4gICAgICBpZiAoZGVsdGEgPT09IDApIHtcclxuICAgICAgICB0b2tlbnMucHVzaCh7XHJcbiAgICAgICAgICB0eXBlOiBkZWZhdWx0VHlwZSxcclxuICAgICAgICAgIGNvbnRlbnQ6IHRleHRcclxuICAgICAgICB9KVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQodGhpcy5fcGFyc2VSdWxlcyh0ZXh0LCBydWxlTmFtZXMsIGRlZmF1bHRUeXBlKSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRva2Vuc1xyXG4gIH1cclxuICBfdG9rZW5pemUgKHNyYykge1xyXG4gICAgbGV0IHRva2VucyA9IHRoaXMuX3BhcnNlUnVsZXMoc3JjKVxyXG5cclxuICAgIGNvbnN0IElOSkVDVElPTl9SRUdJT04gPSBbJ2luamVjdGlvbl9iZWdpbicsICdpbmplY3Rpb25fZW5kJ11cclxuXHJcbiAgICBsZXQgaGVhZEluZGV4ID0gdG9rZW5zLmZpbmRJbmRleCgodCkgPT4gdC50eXBlID09PSAnaGVhZF90ZXh0JylcclxuICAgIHRoaXMuX2V4cGFuZFRva2VuKHRva2VucywgaGVhZEluZGV4LCBJTkpFQ1RJT05fUkVHSU9OKVxyXG5cclxuICAgIGxldCBib2R5SW5kZXggPSB0b2tlbnMuZmluZEluZGV4KCh0KSA9PiB0LnR5cGUgPT09ICdib2R5X3RleHQnKVxyXG4gICAgdGhpcy5fZXhwYW5kVG9rZW4odG9rZW5zLCBib2R5SW5kZXgsIElOSkVDVElPTl9SRUdJT04pXHJcblxyXG4gICAgcmV0dXJuIHRva2Vuc1xyXG4gIH1cclxuICBfZXhwYW5kVG9rZW4gKHRva2VucywgaW5kZXgsIHJ1bGVOYW1lcykge1xyXG4gICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuXHJcbiAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaW5kZXhdXHJcbiAgICB0b2tlbnMuc3BsaWNlKGluZGV4LCAxLCAuLi50aGlzLl9wYXJzZVJ1bGVzKHRva2VuLmNvbnRlbnQsIHJ1bGVOYW1lcywgdG9rZW4udHlwZSkpXHJcbiAgfVxyXG4gIF9yZWR1Y2VCbG9jayAodG9rZW5zKSB7XHJcbiAgICBsZXQgcm9vdCA9IG5ldyBEb2N1bWVudCgpXHJcbiAgICBsZXQgc3RhY2sgPSBbIHJvb3QgXVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvcCAoKSB7IHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAxXSB9XHJcblxyXG4gICAgdG9rZW5zLmZvckVhY2goKHRva2VuKSA9PiB7XHJcbiAgICAgIGxldCBbdCwgcF0gPSB0b2tlbi50eXBlLnNwbGl0KCdfJylcclxuICAgICAgc3dpdGNoIChwKSB7XHJcbiAgICAgICAgY2FzZSAnYmVnaW4nOlxyXG4gICAgICAgICAgc3RhY2sucHVzaChCbG9jay5tYWtlKHQsIHRva2VuKSlcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgY2FzZSAnZW5kJzpcclxuICAgICAgICAgIGxldCBibG9jayA9IHN0YWNrLnBvcCgpXHJcbiAgICAgICAgICBpZiAoYmxvY2sudHlwZSAhPT0gdCkgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBObyBtYXRjaGluZyAnJHt0fV9iZWdpbidgKVxyXG4gICAgICAgICAgYmxvY2suZW5kID0gdG9rZW5cclxuICAgICAgICAgIHRvcCgpLmFwcGVuZChibG9jaylcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHRvcCgpLmFwcGVuZCh0b2tlbilcclxuICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICBpZiAoc3RhY2subGVuZ3RoID4gMSkgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBObyBtYXRjaGluZyAnJHt0b3AoKS50eXBlfV9lbmQnYClcclxuXHJcbiAgICByZXR1cm4gcm9vdFxyXG4gIH1cclxuICBwYXJzZSAoc3JjKSB7XHJcbiAgICBsZXQgdG9rZW5zID0gdGhpcy5fdG9rZW5pemUoc3JjKVxyXG5cclxuICAgIGxldCBkb2MgPSB0aGlzLl9yZWR1Y2VCbG9jayh0b2tlbnMpXHJcblxyXG4gICAgcmV0dXJuIGRvY1xyXG4gIH1cclxufVxyXG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
